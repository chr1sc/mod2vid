#!/usr/bin/env bash
# mod2vid
# 2025 Christian Czinzoll
# License: MIT
VER=0.1.4

set -euo pipefail
################################################################################
# CONSTANTS AND DEFAULTS
readonly DEFAULT_DELAY=1.2
readonly MAX_DELAY=5.0
readonly MIN_DELAY=0.1
# WAIT_BEFORE_MPT
# This value is important.  Depending on the speed of your computer, this
# value may need to be increased (for slower computers) or set lower (for
# faster ones). It refers to the wait time between opening an xterm
# window and starting openmpt123. The terminal video recorded here may
# be asynchronous in the final video accordingly. You can modify the
# value with the --delay|-d option
WAIT_BEFORE_MPT=$DEFAULT_DELAY

# AUDIO NORMALIZATION
# headroom target
readonly TARGET_DBFS=-0.2

################################################################################
# CONFIGURABLE OPTIONS (CAN BE SET AS ENVIRONMENT VARIABLES)
# Do not normalize by default
: "${NORMALIZE:=0}"

# Pattern display: black:black background; white:white background
: "${TERM_THEME:=black}"  # "white" for inverted

# XXX Currently NOT Working with dummy device: $ sudo modprobe snd-dummy
# Just a nasty hack that starts openmpt123 with --gain -80
# This option will also remove the vu meters at the top as they are
# showing nothing anyway (they would just distract)
: "${SUPPRESS_AUDIO:=0}"  # 1 to mute playback

# FONT FOR openmpt123 --info output
: "${FONT_MONO:=/usr/share/fonts/truetype/liberation/LiberationMono-Regular.ttf}"
# VIDEO TITLE
: "${FONT_FILE:=/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf}"
: "${FONT_SIZE:=60}"
: "${FONT_COLOR:=yellow@0.5}" # color@transparency
: "${TEXT_POSITION:=x=(w-text_w)/2:y=60}"

# EQUALIZER SETTINGS
: "${EQ_MODE:=line}"     # allowed: bar, dot, line
: "${EQ_FSCALE:=log}"    # Frequency scale; allowed: lin, log, rlog
: "${EQ_ASCALE:=log}"    # Amplitude scale; allowed: lin, sqrt, cbrt, log
: "${EQ_COL1:=cyan}"     # color string, no strict check here
: "${EQ_COL2:=magenta}"  # color string, no strict check here
: "${EQ_COLS_ALPHA:=0.6}"
: "${EQ_HEIGHT:=200}"    # must be a positive integer
: "${EQ_WINSIZE:=2048}"  # must be a positive integer, typical sizes: 256,512,1024...

: "${SHOW_WAVES:=1}"
: "${WAVES_COLOR:=yellow}"
: "${WAVES_SIZE:=600x60}"
: "${WAVES_POS:=$(( (1920 - ${WAVES_SIZE%x*}) / 2 )):100}"

: "${SHOW_SPECTRUM:=0}"
: "${SPECTRUM_POS:=0:400}"
: "${SPECTRUM_SIZE:=400x400}"
: "${SPECTRUM_COLOR:=rainbow}"
# channel|intensity|rainbow|moreland|nebulae|fire|fiery|fruit|cool|magma|green|viridis|plasma|cividis|terrain
: "${SHOW_OVERVIEW:=0}"
: "${OVERVIEW_SIZE:=1180x40}"
: "${OVERVIEW_POS:=$(( (1920 - ${OVERVIEW_SIZE%x*}) / 2 )):140}"
: "${OVERVIEW_COLOR:=nebulae}"

: "${PAT_HEIGHT:=720}"   # pattern view height
: "${PAT_X:=0}"          # positive value: position right of the center
: "${PAT_Y:=0}"          # positive value: position below the center

: "${TEXT:=\{artist\} - \{title\}}"

export DISPLAY=":99"
SKIP_TERM=0
SETTINGS_FILE=""
IMAGE=""
MODULE=""
CUSTOM_WAV=""
AUDIO=""
WAV=""
AUDIO_DURATION=0
BASENAME=""
GAIN=0
COLS="80"
ROWS="24"
GEOM=""
META=0
POSITIONAL=()
TERMVID=""
OUTVID=""
TRACK_INFO=""
# if -Q (NO_TRACK_INFO) was specified and no background image or
# video was loaded there will be no track info either
NO_TRACK_INFO=0

RED=$(tput setaf 1)
GREEN=$(tput setaf 2)
YELLOW=$(tput setaf 3)
BLUE=$(tput setaf 4)
BOLD=$(tput bold)
RESET=$(tput sgr0)

die() {
	local code=${2:-1}
	echo "${RED}Error: $1${RESET}" >&2
	exit "$code"
}
ensure_file_exists() {
	[[ -f "$1" ]] || die "Missing file: $1"
}
ensure_file_readable() {
    ensure_file_exists "$1" && [[ -r "$1" ]] || die "File not readable: $1"
}


is_image_file() {
	local file="$1"
	file "$file" | grep -qE 'image|bitmap'
}

# Only Debian help for now
check_environment() {
	local tools=(openmpt123 ffmpeg sox convert xterm Xvfb xwininfo)
	for tool in "${tools[@]}"; do
		command -v "$tool" >/dev/null || {
			echo "${RED}Missing: $BOLD$tool$RESET"
			echo -en "If you're on Debian/Ubuntu/Mint, install packages with"
			echo "  sudo apt install openmpt123 ffmpeg sox imagemagick xterm xvfb x11-utils"
			exit 1
		}
	done
}

check_environment TOOLS_NEEDED PKGS_NEEDED

XVFB_PID=""
cleanup() {
  # kill Xvfb if running
  [[ -n "$XVFB_PID" ]] && kill "$XVFB_PID" 2>/dev/null
  rm -f "$TMP_WAV" "$TERMVID.lock" 2>/dev/null
}

escape_text_for_ffmpeg() {
    local text="$1"
    if [[ -n "$text" ]]; then
        # Escape \ and ' (backslash and single quote)
        text="${text//\\/\\\\}"
        text="${text//\'/\\\'}"
        # Escape : and , by prefixing with backslash
        text="${text//:/\\:}"
        text="${text//,/\\,}"
        echo "$text"
    fi
}

get_filter_complex() {
  local filter_complex="\
    [1:v]colorkey=black:0.4:0.3,scale=-1:${PAT_HEIGHT},pad=1920:1080:'(ow-iw)/2 + (${PAT_X})':'(oh-ih)/2 + (${PAT_Y})'[term];\
    [3:v]scale=1920:1080,format=yuva420p,colorchannelmixer=aa=0.8[outerbg];\
    [2:v]scale=1920:1080,format=yuva420p,colorchannelmixer=aa=0.4[innerbg];\
    [outerbg][term]overlay=format=auto[tmp];\
    [tmp][innerbg]overlay=(W-w)/1.5:(H-h)/1.5[base];"

  local overlay_input="[base]"
  local overlay_count=0

  # SHOW_OVERVIEW
  if [[ "$SHOW_OVERVIEW" -eq 1 ]]; then
    filter_complex+="\
      [0:a]showspectrumpic=s=${OVERVIEW_SIZE}:scale=log[overview_raw];\
      [overview_raw]crop=w=${OVERVIEW_SIZE%x*}:h=${OVERVIEW_SIZE#*x}:x=0:y=0[overview_crop];\
      [overview_crop]format=rgba,colorkey=black:0.1:0.3[overview];\
      color=c=black@0:s=${OVERVIEW_SIZE}:d=${AUDIO_DURATION},format=rgba,\
        drawbox=x='t/${AUDIO_DURATION}*${OVERVIEW_SIZE%x*}':y=0:w=4:h=${OVERVIEW_SIZE#*x}:color=red@0.8:t=fill[marker];\
      [overview][marker]overlay=format=auto[overview_marker];\
      ${overlay_input}[overview_marker]overlay=${OVERVIEW_POS}[vis${overlay_count}];"
    overlay_input="[vis${overlay_count}]"
    ((overlay_count++))
  fi

  # SHOW_WAVES
  if [[ "$SHOW_WAVES" -eq 1 ]]; then
    filter_complex+="\
      [0:a]showwaves=s=${WAVES_SIZE}:mode=line:colors=${WAVES_COLOR}[wavevis];\
      ${overlay_input}[wavevis]overlay=${WAVES_POS}[vis${overlay_count}];"
    overlay_input="[vis${overlay_count}]"
    ((overlay_count++))
  fi

  # SHOW_SPECTRUM
  if [[ "$SHOW_SPECTRUM" -eq 1 ]]; then
    filter_complex+="\
      [0:a]showspectrum=s=${SPECTRUM_SIZE}:mode=combined:color=nebulae[specvis];\
      ${overlay_input}[specvis]overlay=${SPECTRUM_POS}[vis${overlay_count}];"
    overlay_input="[vis${overlay_count}]"
    ((overlay_count++))
  fi

  # EQ & Final Overlays
  filter_complex+="\
    [0:a]showfreqs=s=1920x${EQ_HEIGHT}:\
      mode=${EQ_MODE}:\
      fscale=${EQ_FSCALE}:\
      ascale=${EQ_ASCALE}:\
      colors=${EQ_COL1}|${EQ_COL2}:\
      win_size=${EQ_WINSIZE}:\
      overlap=0[eq];\
    ${overlay_input}[eq]overlay=0:$((1080 - EQ_HEIGHT))[final];\
    [final]drawtext=text='github.com/chr1s/mod2vid':x=4:y=h-th-4:fontsize=20:\
      fontcolor=white@0.2:shadowx=2:shadowy=2[tmp_draw];\
    [tmp_draw]drawtext=text='${TEXT}':\
      fontcolor=${FONT_COLOR}:\
      fontsize=${FONT_SIZE}:\
      fontfile=${FONT_FILE}:\
      ${TEXT_POSITION}:\
      shadowx=4:shadowy=4[outv]"

  echo "${filter_complex}"
}


################################################################################
# template functions to substitute placeholders in -t with their values
read_openmpt_info() {
  local file="$1"
  openmpt123 --info "$file"|grep -F '.:'|grep -vF 'warning:'
}
get_info_field() {
	local field="$1"
	echo "$TRACK_INFO" | awk -F': +' -v key="$field" '
		{
			gsub(/^[ \t.]+|[ \t.]+$/, "", $1)
			if ($1 == key) print $2
		}
	'
}

get_module_year_label() {
	local file="$1"
	local raw_date
	raw_date=$(get_info_field "Date")

	if [[ -n "$raw_date" ]]; then
		echo "$(cut -c1-4 <<< "$raw_date")"
	else
		#local fake_date=$(stat -c %w "$file" 2>/dev/null | cut -c1-4)
		#echo "${fake_date}"
		echo "?"
	fi
}
build_text() {
	local template="$1"
	local artist=$(get_info_field "Artist")
	local title=$(get_info_field "Title")
	local filename=$(basename "${MODULE%%.*}")
	local size=$(get_info_field "Size")
	local duration=$(get_info_field "Duration")
	local year=$(get_module_year_label "$MODULE")
	# fallback values
	[[ -z "$title" ]] && title="$filename"
	[[ -z "$artist" ]] && artist="?"

	local result="$template"
	result=${result//\{artist\}/$artist}
	result=${result//\{title\}/$title}
	result=${result//\{filename\}/$filename}
	result=${result//\{size\}/$size}
	result=${result//\{duration\}/$duration}
	result=${result//\{year\}/$year}

	echo "$result"
}


usage() {
	cat <<EOF
mod2vid v$VER -- 2025 by Christian Czinzoll
Usage: ${0##*/} [OPTIONS] <module.it>

Create music videos from tracker modules with terminal visualization

Arguments:
  <module.it>         Path to a .it/.mod/.xm file for openmpt123

Options:
  -b, --background <file>    Background image/video (default: $HOME/Videos/bg.webm)
  -i, --input-audio <file>   Use custom audio file instead of rendering module
                             (Useful for tracks with VST plugins that need
                             to be rendered in OpenMPT first)
  -t, --text "text"          Text overlay displayed at top of video
  -g, --gain <db>            Amplify output by <db> (0-10, default: 0)
  -n, --normalize            Amplify to 0dbFS
  -c, --columns <width>      Terminal width in characters (default: 80)
  -r, --rows <height>        Terminal height in characters (default: 24)
  -d, --delay <seconds>      Delay before recording starts (0.1-5, default: $WAIT_BEFORE_MPT)
  -s, --skip-term            Skip terminal recording if _term.mp4 exists
  -N, --no-metadata          Strip all metadata from output video
  -Q, --no-trackinfo         If no -b was specified, the video will show some track info.
                             You can turn off this behavior with this switch.
  -h, --help                 Show this help message

Examples:
  ${0##*/} song.it -t "Epic Track" -n
  ${0##*/} -i final.wav -b background.jpg song.xm
  ${0##*/} --text "Demo" --no-metadata module.mod
  ${0##*/} -t "Retro" -c 100 -r 30 song.it
EOF
	exit 1
}

render_audio() {
	[[ -n "$CUSTOM_WAV" ]] && {
		echo "Using provided audio: $CUSTOM_WAV"
		return
	}

	echo "Rendering audio..."

	if [[ "$NORMALIZE" == 1 ]]; then
		# when NORMALIZE is active
		# we have to do the wav render twice in order to determine
		# the level of amplification we can apply
		openmpt123 --render --force "$MODULE" 2>&1 >/dev/null
		local peak_dbfs=$(sox "$WAV" -n stat 2>&1 \
				| awk '/Maximum amplitude/ {print 20*log($3)/log(10)}')
		GAIN=$(awk -v db="$peak_dbfs" -v tgt="$TARGET_DBFS" 'BEGIN {
			printf("%d", int(tgt - db))
		}')

		# no need to render the wav a second time if there is nothing
		# to gain :D
		if [[ "$GAIN" -le 0 ]]; then
			return
		fi
		echo "Will gain the audio by $GAIN dB"
	fi

	openmpt123 --render --force --gain "$GAIN" "$MODULE"
}

record_terminal() {
	if [[ "$SKIP_TERM" == 1 && -f "$TERMVID" ]]; then
		echo "Skipping terminal recording (using existing: $TERMVID)"
		return
	fi

	echo "Starting headless terminal recording..."
	start_xvfb

	local xterm_cmd
	xterm_cmd=$(build_xterm_command)
	run_xterm "$xterm_cmd" &
	local XTERM_PID=$!
	sleep 1

	detect_window_geometry
	AUDIO_DURATION=$(get_media_duration "$WAV")

	record_x11 "$AUDIO_DURATION"
	local FFMPEG_PID=$!

	wait "$XTERM_PID"
	sleep 1
	kill "$FFMPEG_PID" "$XVFB_PID" 2>/dev/null || true
}

start_xvfb() {
	Xvfb ":99" -screen 0 1920x1080x24 +extension RANDR &>/dev/null &
	XVFB_PID=$!
	#trap 'cleanup' EXIT ERR
	sleep 1
}

build_xterm_command() {
	local cmd=(-fa Monospace -fs 10 -geometry "$GEOM")
	if [[ "$TERM_THEME" == "white" ]]; then
		cmd+=(-bg white -fg black -cr black)
	else
		cmd+=(-bg black -fg white -cr white)
	fi

	local mpt_args=(--progress --channel-meters --pattern "$MODULE")
	if [[ "$SUPPRESS_AUDIO" == 1 ]]; then
		mpt_args+=(--no-meters --gain -80)
	else
		mpt_args+=(--gain "$GAIN")
	fi

	local exec_cmd="sleep $WAIT_BEFORE_MPT; openmpt123 ${mpt_args[*]}; clear; sleep 2"
	cmd+=(-e "$exec_cmd")
	printf '%q ' "${cmd[@]}"
}

run_xterm() {
	eval xterm "$1"
}

detect_window_geometry() {
	W=800 H=600
	if WIN_ID=$(xwininfo -root -children | awk '/xterm/ {print $1; exit}'); then
		eval "$(xwininfo -id "$WIN_ID" | awk -F: '
			/Width/  { gsub(/^[ \t]+/, "", $2); w=$2 }
			/Height/ { gsub(/^[ \t]+/, "", $2); h=$2 }
			END      { printf "W=%s\nH=%s\n", w, h }
		')"
	fi
}

get_media_duration() {
	local file="$1"
	ffprobe -hide_banner -v error -show_entries format=duration \
		-of default=nokey=1:noprint_wrappers=1 "$file"
}

record_x11() {
	local duration="$1"
	ffmpeg -hide_banner -y -f x11grab -video_size "${W}x${H}" \
		-framerate 30 -i ":99+0,0" \
		-pix_fmt yuv420p -c:v libx264 -preset ultrafast \
		-t "$duration" "$TERMVID"
}

compose_final_video() {
	echo "Creating final video..."
	AUDIO_DURATION=$(get_media_duration "$AUDIO")

	# is our background an image or a video
	local image_input=()
	if is_image_file "$IMAGE"; then
		image_input=(-loop 1 -framerate 30)
	else
		image_input=(-stream_loop -1)
	fi

	local metadata_flag=()
	[[ "$META" -eq 1 ]] && metadata_flag=(-map_metadata -1)

	local filter_complex=$(get_filter_complex)
	local map_out="[outv]"

	ffmpeg -hide_banner -y \
		-i "$AUDIO" \
		-i "$TERMVID" \
		"${image_input[@]}" -i "$IMAGE" \
		"${image_input[@]}" -i "$IMAGE" \
		"${metadata_flag[@]}" \
		-filter_complex "$filter_complex" \
		-map 0:a \
		-map "$map_out" \
		-c:v libx264 -preset slow -crf 18 -pix_fmt yuv420p \
		-shortest \
		"$OUTVID"
}


generate_track_info_image() {
	local module_file="$1"
	local basename="$2"
	local font="$FONT_MONO"
	local output="${basename}_info.png"

	# just generate a black background
	if (( NO_TRACK_INFO == 1 )); then
		if ! convert -size 1920x1080 xc:black \
					"$output"; then
			echo "Error: Failed to create image with convert" >&2
			exit 1
		fi
		return
	fi

	if ! convert -size 1920x1080 xc:black -fill white \
				-font "$font" \
				-pointsize 16 -annotate +10+100 "$TRACK_INFO" \
				"$output"; then
		echo "Error: Failed to create image with convert" >&2
		exit 1
	fi
}

parse_args() {
	while [[ $# -gt 0 ]]; do
		case "$1" in
			-l|--load-settings) SETTINGS_FILE="$2"; shift 2 ;;
			-b|--background)  IMAGE="$2"; shift 2 ;;
			-i|--input-audio) CUSTOM_WAV="$2"; AUDIO="$2"; shift 2 ;;
			-t|--text)        TEXT="$2"; shift 2 ;;
			-g|--gain)        GAIN="$2"; shift 2 ;;
			-c|--columns)     COLS="$2"; shift 2 ;;
			-r|--rows)        ROWS="$2"; shift 2 ;;
			-d|--delay)       WAIT_BEFORE_MPT="$2"; shift 2 ;;
			-s|--skip-term)   SKIP_TERM=1; shift ;;
			-Q|--no-trackinfo)NO_TRACK_INFO=1; shift ;;
			-N|--no-metadata) META=1; shift ;;
			-n|--normalize)   NORMALIZE=1; shift ;;
			-h|--help)        usage; exit 0 ;;
			--)               shift; POSITIONAL+=("$@"); break ;;
			-*|--*)           echo "Error: Unknown option $1"; usage; exit 1 ;;
			*)                POSITIONAL+=("$1"); shift ;;
		esac
	done
}

validate_args() {
	if [ -n "$SETTINGS_FILE" ]; then
		ensure_file_readable "$SETTINGS_FILE"
		source "$SETTINGS_FILE"
	fi
	if [[ ! -f "$FONT_FILE" ]]; then
		echo "Warning: Font file not found: $FONT_FILE (using default)" >&2
	fi
	if [[ ${#POSITIONAL[@]} -gt 0 ]]; then
		MODULE="${POSITIONAL[0]}"
		if [[ ${#POSITIONAL[@]} -gt 1 ]]; then
			echo "Warning: Extra arguments ignored: ${POSITIONAL[*]:1}"
		fi
	fi

	[[ -z "$MODULE" ]] && {
		echo "Error: Module file required"
		usage
		exit 1
	}

	BASENAME="${MODULE%.*}"
	WAV="${MODULE}.wav"
	[[ -z "$CUSTOM_WAV" ]] && AUDIO="$WAV"

	if [[ $NORMALIZE -eq 1 && -n $CUSTOM_WAV ]]; then
		die "Will not normalize (-n) pre-recorded (-i) audio files" 2
	fi
	if [[ $NORMALIZE -eq 1 && $GAIN -ne 0 && $SUPPRESS_AUDIO -eq 0 ]]; then
		die "Normalize (-n) and Gain (-g) collision" 2
	fi
	[[ -z "$TEXT" ]] && {
		TEXT="$(basename "${BASENAME//_/ }")"
	}

	TERMVID="${BASENAME}_term.mp4"
	OUTVID="${BASENAME}.mp4"
	GEOM="${COLS}x${ROWS}"

	# get the module and track info (-t)
	[[ -z "$MODULE" ]] && usage
	[[ ! -f "$MODULE" ]] && die "Module not existing: $MODULE" 2
	TRACK_INFO=$(read_openmpt_info "$MODULE");
	TEXT="$(build_text "$TEXT")"
	TEXT="$(escape_text_for_ffmpeg "$TEXT")"

	if ! [[ "$GAIN" =~ ^-?[0-9]+(\.[0-9]+)?$ ]]; then
		die "Gain is not a valid number" 2
	fi
	# just some arbitrary bounds
	if ! bc <<< "$GAIN >= -80 && $GAIN <= 80" | grep -q 1; then
		die "Gain is out of range (-80..80)" 2
	fi
	# ditto
	if (( $(bc <<< "$WAIT_BEFORE_MPT < $MIN_DELAY || $WAIT_BEFORE_MPT > $MAX_DELAY") )); then
		die "Delay value must be between $MIN_DELAY and $MAX_DELAY seconds" 2
	fi
	# if no -b was specified we are going to display some track infos
	if [[ -z "$IMAGE" ]]; then
		generate_track_info_image "$MODULE" "$BASENAME"
		IMAGE="${BASENAME}_info.png"
	fi
	if [[ ! -f "$IMAGE" ]]; then
		die "Couldn't open background file: $IMAGE" 1
	fi

	case "$EQ_MODE" in
		bar|dot|line) ;;
		*) EQ_MODE=dot ;;
	esac
	case "$EQ_FSCALE" in
		lin|log|rlog) ;;
		*) EQ_FSCALE=lin ;;
	esac
	case "$EQ_ASCALE" in
		lin|sqrt|cbrt|log) ;;
		*)
			echo "Warning: EQ_ASCALE='$EQ_ASCALE' invalid, falling back to default 'lin'" >&2
			EQ_ASCALE=lin
			;;
	esac
	if ! [[ "$EQ_HEIGHT" =~ ^[0-9]+$ ]] || (( EQ_HEIGHT <= 0 )); then
		EQ_HEIGHT=200
	fi
	if ! [[ "$EQ_WINSIZE" =~ ^[0-9]+$ ]] || (( EQ_WINSIZE <= 0 )); then
		EQ_WINSIZE=512
	fi

	if ! [[ "$EQ_COLS_ALPHA" =~ ^0(\.[0-9]+)?$|^1(\.0*)?$ ]]; then
		echo "Warning: EQ_COLS_ALPHA='$EQ_COLS_ALPHA' invalid, falling back to default 0.6" >&2
		EQ_COLS_ALPHA=0.6
	fi
	case "$SPECTRUM_COLOR" in
		channel|intensity|rainbow|moreland|nebulae|fire|fiery|fruit|cool|magma|green|viridis|plasma|cividis|terrain)
			;;
		*)
			SPECTRUM_COLOR="channel"
			echo "Warning: Invalid SPECTRUM_COLOR '$SPECTRUM_COLOR', using default 'channel'" >&2
			;;
	esac
	case "$OVERVIEW_COLOR" in
		channel|intensity|rainbow|moreland|nebulae|fire|fiery|fruit|cool|magma|green|viridis|plasma|cividis|terrain)
			;;
		*)
			OVERVIEW_COLOR="channel"
			echo "Warning: Invalid OVERVIEW_COLOR '$OVERVIEW_COLOR', using default 'channel'" >&2
			;;
	esac
}

main() {
	parse_args "$@"
	validate_args
	check_environment
	render_audio
	record_terminal
	compose_final_video
	echo "Done: $OUTVID"
}

main "$@"
